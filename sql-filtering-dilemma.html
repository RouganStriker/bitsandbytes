<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SQL Filtering Dilemma - bitsandbytes</title><meta name="description" content="Suppose you are querying against a very large table in your database with some amount of filtering involved. What is the most optimal way to construct and execute this query? tldr; it depends so analyze and measure first. Query filter without joins &lt; Query with&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://rouganstriker.github.io/bitsandbytes/sql-filtering-dilemma.html"><link rel="alternate" type="application/atom+xml" href="https://rouganstriker.github.io/bitsandbytes/feed.xml"><link rel="alternate" type="application/json" href="https://rouganstriker.github.io/bitsandbytes/feed.json"><meta property="og:title" content="SQL Filtering Dilemma"><meta property="og:image" content="https://rouganstriker.github.io/bitsandbytes/media/posts/3/IMG_7203.jpg"><meta property="og:image:width" content="4898"><meta property="og:image:height" content="3265"><meta property="og:site_name" content="bitsandbytes"><meta property="og:description" content="Suppose you are querying against a very large table in your database with some amount of filtering involved. What is the most optimal way to construct and execute this query? tldr; it depends so analyze and measure first. Query filter without joins &lt; Query with&hellip;"><meta property="og:url" content="https://rouganstriker.github.io/bitsandbytes/sql-filtering-dilemma.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://rouganstriker.github.io/bitsandbytes/assets/css/style.css?v=8472f1bfe4b0fdb01c59d1d3fa980ec3"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://rouganstriker.github.io/bitsandbytes/sql-filtering-dilemma.html"},"headline":"SQL Filtering Dilemma","datePublished":"2024-02-17T17:49","dateModified":"2024-02-17T17:49","image":{"@type":"ImageObject","url":"https://rouganstriker.github.io/bitsandbytes/media/posts/3/IMG_7203.jpg","height":3265,"width":4898},"description":"Suppose you are querying against a very large table in your database with some amount of filtering involved. What is the most optimal way to construct and execute this query? tldr; it depends so analyze and measure first. Query filter without joins &lt; Query with&hellip;","author":{"@type":"Person","name":"Nyfor","url":"https://rouganstriker.github.io/bitsandbytes/authors/nyfor/"},"publisher":{"@type":"Organization","name":"Nyfor"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://rouganstriker.github.io/bitsandbytes/">bitsandbytes</a></header><main><article class="post"><div class="hero"><figure class="hero__image hero__image--overlay"><img src="https://rouganstriker.github.io/bitsandbytes/media/posts/3/IMG_7203.jpg" srcset="https://rouganstriker.github.io/bitsandbytes/media/posts/3/responsive/IMG_7203-xs.jpg 300w, https://rouganstriker.github.io/bitsandbytes/media/posts/3/responsive/IMG_7203-sm.jpg 480w, https://rouganstriker.github.io/bitsandbytes/media/posts/3/responsive/IMG_7203-md.jpg 768w, https://rouganstriker.github.io/bitsandbytes/media/posts/3/responsive/IMG_7203-lg.jpg 1024w, https://rouganstriker.github.io/bitsandbytes/media/posts/3/responsive/IMG_7203-xl.jpg 1360w, https://rouganstriker.github.io/bitsandbytes/media/posts/3/responsive/IMG_7203-2xl.jpg 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="eager" height="3265" width="4898" alt=""></figure><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-02-17T17:49">February 17, 2024</time></div><h1>SQL Filtering Dilemma</h1><div class="post__meta post__meta--author"><img src="https://rouganstriker.github.io/bitsandbytes/media/website/pusheen.png" loading="eager" height="630" width="630" class="post__author-thumb" alt="Nyfor"> <a href="https://rouganstriker.github.io/bitsandbytes/authors/nyfor/" class="feed__author">Nyfor</a></div></div></header></div><div class="wrapper post__entry"><p>Suppose you are querying against a very large table in your database with some amount of filtering involved. What is the most optimal way to construct and execute this query?</p><p><strong><em>tldr</em><em>; it depends so analyze and measure first.</em></strong></p><p>Query filter without joins &lt; Query with IN filter against static values &lt; Query filter with joinsÂ </p><p>The best query involves no joins at all if the filtering can be done on the table alone. Join operations are notoriously expensive and this is very noticeable when joining against large tables. But if joins are necessary or if the filter is very complex, I've seen situations where the query is broken in half with one query pre-computing the result of the subquery into a list of IDs and then converting the primary query to perform an IN filter against that list of IDs. In some cases this does improve the overall performance of the operation by removing an expensive join operation from the query. However it does come at a cost, when you analyze a query that uses an IN filter with a very large list of values, it has a high planning cost likely due to having to process such a large query. So there will be a break-even point after which the approach of an IN filter with static values will be less performant than a subquery with joins. That break-even point depends on the size and complexity of the filter and join operations so it is important to test and measure before deciding which approach to go with.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on February 17, 2024</p><div class="post__share"></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://rouganstriker.github.io/bitsandbytes/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://rouganstriker.github.io/bitsandbytes/initial-commit.html" class="post__nav-link" rel="prev"><span>Previous</span> Initial Commit</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://rouganstriker.github.io/bitsandbytes/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://rouganstriker.github.io/bitsandbytes/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>